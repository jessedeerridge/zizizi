<!DOCTYPE html>  
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Syzygy</title>
<style>
  /* =========================
     ✅ スクロール禁止
     ========================= */
  html, body{
    height:100%;
    overflow:hidden;
    overscroll-behavior:none;
    touch-action:manipulation;
  }
  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    background:#fff;color:#111;
    position:fixed;
    inset:0;
  }

  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  /* ★ main背景：入室前/入室後で切替 */
  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:hidden;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    touch-action:manipulation;
  }
  main.prejoin{ background-image:url('zitop.jpg'); }
  main.joined{ background-image:url('zimain.jpg'); }

  /* =========================
     ✅ 右上：円は ziwhite.png 画像にする（点線なし）
     ========================= */
  #topRightCircle{
    position:fixed;
    top:72px;
    right:16px;

    width:clamp(110px, 18vw, 160px);
    height:clamp(110px, 18vw, 160px);

    border:none;
    border-radius:50%;
    background:transparent;
    background-image:url('ziwhite.png');
    background-size:contain;
    background-repeat:no-repeat;
    background-position:center;

    z-index:215;
    pointer-events:none;
  }
  #topRightCircle.hidden{ display:none; }

  /* ✅ 円の中に溜まるチップ */
  .circle-chip{
    position:absolute;
    width:26px;height:26px;
    border-radius:50%;
    border:1px solid rgba(0,0,0,.35);
    box-shadow:0 10px 20px rgba(0,0,0,.18);
    display:grid;place-items:center;
    pointer-events:none;
    will-change:transform;
  }

  /* ★ 着席ポップ */
  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:navy;border:1px solid #eee;border-radius:12px;color:#fff;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  /* ★ ホスト人数選択中：参加者に出す黒ポップ（下固定） */
  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:225;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

  /* =========================
     ✅ ネームタグ基準：中央カード列を基準に上下の横線＋その上にタグ
     ========================= */
  #playerLinesWrap{
    position:fixed;
    inset:0;
    z-index:205;
    pointer-events:none;
  }
  #playerLinesWrap.hidden{display:none;}

  .player-line{
    display:none;
    position:absolute;
    height:2px;
    background:rgba(0,0,0,.75);
    border-radius:999px;
    left:50%;
    transform:translateX(-50%);
    width:min(920px, calc(100% - 36px));
    box-shadow:0 1px 0 rgba(255,255,255,.25);
    pointer-events:none;
  }

  /* ✅ スタック（名前＋〇列） */
  .player-stack{
    position:absolute;
    transform:translate(-50%,-50%);
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:6px;
    pointer-events:none;
  }

  .player-tag{
    position:relative;
    padding:4px 8px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
    pointer-events:auto;
    cursor:pointer;
  }
  .player-tag.me{ background:#111;color:#fff;border-color:#111; cursor:default; }

  /* ✅ ネームタグ下のチップ（1..4） */
  .player-dots{
    display:flex;
    gap:3px;
    pointer-events:none;
  }
  .player-stack.me .player-dots{
    pointer-events:auto;
  }
  .player-dot{
    width:26px;height:26px;
    border-radius:50%;
    border:1px solid rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;
    font-size:10px;
    font-weight:900;
    line-height:1;
    box-shadow:0 2px 6px rgba(0,0,0,.12);
    user-select:none;
    position:relative;
    will-change:transform;
  }

  /* ✅ 自分のチップ：ドラッグ可能 */
  .player-stack.me .player-dot{
    cursor:grab;
    touch-action:none;
  }
  .player-stack.me .player-dot:active{cursor:grabbing;}

  /* ✅ 左から順にしか使えない（無効）薄くしない */
  .player-dot.disabled{
    opacity:1;
    cursor:default !important;
    pointer-events:none;
  }

  /* ✅ 使った/ドラッグ中は消える */
  .player-dot.used,
  .player-dot.dragging-hide{
    opacity:0;
    pointer-events:none;
  }

  /* =========================
     ✅ 手番プレイヤーの「そのターンのチップ」パルス（他プレイヤーから見ても）
     ========================= */
  @keyframes turnPulse{
    0%{ transform:scale(1); }
    50%{ transform:scale(1.32); }
    100%{ transform:scale(1); }
  }
  .turn-pulsing{
    animation: turnPulse .85s ease-in-out infinite;
  }

  /* =========================
     ✅ NEW：左右端カード（選択待ち）大小アニメ
     ========================= */
  @keyframes endPulse{
    0%{ transform:scale(1); }
    50%{ transform:scale(1.18); }
    100%{ transform:scale(1); }
  }
  .end-pulsing{
    animation:endPulse .78s ease-in-out infinite;
    transform-origin:center;
    box-shadow:0 16px 30px rgba(0,0,0,.22);
  }

  /* =========================
     ✅ チップ図形（数字→図形）
     ========================= */
  .chip-shape{ width:18px;height:18px; position:relative; display:block; }

  .shape-1{
    border-radius:50%;
    background: radial-gradient(circle, transparent 0 43%, currentColor 44% 100%);
  }

  .shape-2{ display:flex; gap:3px; align-items:stretch; }
  .shape-2::before,
  .shape-2::after{
    content:'';
    flex:1;
    border-radius:0px;
    background:currentColor;
  }

  /* 3 三角を3つ（トライフォース） */
  .shape-3::before{
    content:'';
    position:absolute;
    left:50%;
    top:-1px;
    transform:translateX(-50%);
    width:0;height:0;
    border-left:5px solid transparent;
    border-right:5px solid transparent;
    border-bottom:8px solid currentColor;
  }
  .shape-3::after{
    content:'';
    position:absolute;
    left:22%;
    top:7px;
    transform:translateX(-50%);
    width:0;height:0;
    border-left:5px solid transparent;
    border-right:5px solid transparent;
    border-bottom:8px solid currentColor;
  }
  .shape-3 .tri{
    position:absolute;
    left:77%;
    top:7px;
    transform:translateX(-50%);
    width:0;height:0;
    border-left:5px solid transparent;
    border-right:5px solid transparent;
    border-bottom:8px solid currentColor;
    display:block;
  }

  .shape-4{
    display:grid;
    grid-template-columns:repeat(2, 1fr);
    grid-template-rows:repeat(2, 1fr);
    gap:2px;
  }
  .shape-4::before, .shape-4::after{ content:''; display:none; }
  .shape-4 span{
    width:100%;height:100%;
    border-radius:50%;
    background:currentColor;
    display:block;
  }

  /* ★ 追い出し確認ダイアログ */
  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:300;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  /* ★ ホスト用 設定ボタン（右下固定） */
  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:230;
  }
  .host-settings-btn.visible{display:flex;}

  /* ★ 設定ポップ（ホスト専用パネル） */
  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:240;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  /* 詳細情報消す用 */
  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    min-height:calc(100vh - 60px);
  }

  /* =========================
     ★ 左下「？」ボタン
     ========================= */
  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:230;
  }
  .help-btn.visible{display:flex;}

  /* ★ ヘルプ一覧ポップ */
  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:310;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(70vh, 640px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}

  /* ✅ Help: カード一覧（4列） */
  .help-grid{
    display:grid;
    grid-template-columns:repeat(4, 72px);
    justify-content:center;
    gap:10px;
    padding:2px 0;
  }
  .help-card{
    width:72px;height:108px;border-radius:10px;border:1px solid #ddd;background:#f8f8f8;
    box-shadow:0 6px 16px rgba(0,0,0,.10);
    user-select:none;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    color:transparent;
    text-indent:-9999px;
    overflow:hidden;
  }
  .help-card.dimmed{opacity:.35;}
  .help-card.host-toggle{cursor:pointer;}
  .help-card.host-toggle:active{transform:scale(.98);}

  /* =========================
     ★ 上下中央のカード列
     ========================= */
  #centerRowWrap{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    z-index:210;
    width:calc(100% - 24px);
    pointer-events:auto;

    --cc-w: 68px;
    --cc-h: 96px;
    --cc-gap: 10px;
    --cc-font: 18px;
    --cc-padX: 10px;
    --cc-padY: 10px;

    --cc-insFactor: 0.95;
  }
  .center-row{
    display:flex;
    justify-content:center;
    align-items:center;
    gap:var(--cc-gap);
    padding:var(--cc-padY) var(--cc-padX);
    border-radius:16px;
    background:transparent;
    user-select:none;
    position:relative;
    overflow:visible;
    touch-action:none;
    -webkit-user-select:none;
  }

  .center-card{
    width:var(--cc-w);
    height:var(--cc-h);
    border-radius:calc(var(--cc-w) * 0.14);
    border:1px solid rgba(0,0,0,.18);
    background:#fff;
    box-shadow:0 10px 20px rgba(0,0,0,.14);
    cursor:grab;
    position:relative;
    flex:0 0 auto;
    transition:none;
    will-change: transform;

    touch-action:none;
    -webkit-user-select:none;

    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;

    color:transparent;
    text-indent:-9999px;
    overflow: visible;
  }
  .center-card:active{cursor:grabbing;}
  .center-row.dragging .center-card{transition:none;}

  .center-ghost{
    width:var(--cc-w);
    height:var(--cc-h);
    border-radius:calc(var(--cc-w) * 0.14);
    flex:0 0 auto;
    visibility:hidden;
    pointer-events:none;
  }

  /* ✅ タッチ用：指に追従するフローティングカード（並び替え時） */
  .drag-float{
    position:fixed;
    left:0; top:0;
    z-index:9999;
    width:var(--cc-w);
    height:var(--cc-h);
    border-radius:calc(var(--cc-w) * 0.14);
    border:1px solid rgba(0,0,0,.18);
    background:#fff;
    box-shadow:0 10px 20px rgba(0,0,0,.14);
    pointer-events:none;
    transform:translate(-9999px,-9999px);

    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;

    color:transparent;
    text-indent:-9999px;
    overflow: visible;
  }

  /* ✅ カード移動時のinsertMarkerを透明化 */
  #insertMarker{
    position:absolute;
    top:0;
    left:-9999px;
    width:calc(var(--cc-w) * var(--cc-insFactor));
    height:var(--cc-h);
    border-radius:calc(var(--cc-w) * 0.14);
    background:transparent;
    box-shadow:none;
    outline:none;
    pointer-events:none;
    opacity:0;
    transition:opacity .06s linear;
  }
  #insertMarker.visible{ opacity:1; filter: drop-shadow(0 0 10px rgba(0,0,0,.18)); }

  /* ✅ チップ：カード上に置かれた表示（半分サイズ・中央縦並び） */
  .card-chip-stack{
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:3px;
    pointer-events:none;
    z-index:3;
  }
  .placed-chip{
    width:14px;height:14px;
    border-radius:50%;
    border:1px solid rgba(0,0,0,.32);
    display:grid;place-items:center;
    box-shadow:0 2px 6px rgba(0,0,0,.18);
    will-change:transform;
  }
  .placed-chip .chip-shape{ width:10px;height:10px; }
  .placed-chip .shape-2{gap:2px;}
  .placed-chip .shape-3::before{
    border-left:3px solid transparent;
    border-right:3px solid transparent;
    border-bottom:5px solid currentColor;
    top:-1px;
  }
  .placed-chip .shape-3::after{
    border-left:3px solid transparent;
    border-right:3px solid transparent;
    border-bottom:5px solid currentColor;
    top:4px; left:24%;
  }
  .placed-chip .shape-3 .tri{
    border-left:3px solid transparent;
    border-right:3px solid transparent;
    border-bottom:5px solid currentColor;
    top:4px; left:76%;
  }
  .placed-chip .shape-4{gap:1px;}

  /* ✅ チップ用フローティング */
  .chip-float{
    position:fixed;
    left:0; top:0;
    z-index:10000;
    width:26px;height:26px;
    border-radius:50%;
    border:1px solid rgba(0,0,0,.35);
    box-shadow:0 10px 20px rgba(0,0,0,.18);
    display:grid;
    place-items:center;
    pointer-events:none;
    transform:translate(-9999px,-9999px);
  }

  /* =========================
     ✅ カード拡大（表）表示：ローカル専用オーバーレイ
     ========================= */
  .zoom-backdrop{
    position:fixed; inset:0;
    background:rgba(0,0,0,.55);
    display:flex; align-items:center; justify-content:center;
    z-index:12000;
    padding:16px;
  }
  .zoom-backdrop.hidden{ display:none; }
  .zoom-card{
    width:min(280px, 82vw);
    aspect-ratio: 2 / 3;
    border-radius:18px;
    border:1px solid rgba(255,255,255,.18);
    box-shadow:0 22px 60px rgba(0,0,0,.45);
    background:#fff;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    transform:scale(1);
  }
</style>
</head>
<body>

<header>
  <h1>Syzygy</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>
  </div>
</main>

<!-- ✅ 右上の円（画像）※入室後に表示 -->
<div id="topRightCircle" class="hidden" aria-hidden="true"></div>

<!-- ✅ ネームタグの基準：中央カード列の上下に横線 -->
<div id="playerLinesWrap" class="hidden" aria-label="プレイヤーライン">
  <div id="playerLineTop" class="player-line"></div>
  <div id="playerLineBottom" class="player-line"></div>
</div>

<div id="centerRowWrap" class="hidden">
  <div id="centerRow" class="center-row" aria-label="中央カード列">
    <div id="insertMarker"></div>
  </div>
</div>

<div id="hostSelectingPop" class="host-selecting-pop hidden">ホストが人数を選択中</div>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>

<button id="helpBtn" class="help-btn" title="正体カード一覧">？</button>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="正体カード一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">正体カード</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    「スタート」で中央にカード列を生成（上書きします）。<br>
    ※ Helpで「10」「X」を有効/無効にできます（ホストのみ）。<br>
    ※ Helpの変更は<strong>スタートを押すまで中央列に反映しません</strong>（今ある列は更新しない）。<br>
    ※ Xが有効のときは、数字カードの中から<strong>ランダムで1枚だけ除外</strong>して並べます（除外は表示上わからない）。<br><br>
    ✅ Start時に「全員の所持チップ」を復活（chipUsedを全部falseに戻す）します。<br>
    ✅ Start時に「右上の円（チップ溜め）」も空にします。<br><br>
    ✅ 変更仕様：<strong>チップを置いた後</strong>、カードの並びを<strong>変える移動を1回</strong>したら手番終了。<br>
    （並びが変わらない移動は終了しない）<br>
    ✅ NEW：<strong>チップを右上円に入れた場合はその時点で手番終了</strong><br>
    ✅ NEW：<strong>チップを置いたら表拡大を1.2秒表示 → 消えてから「そのカードだけ」移動可能</strong><br>
    ✅ NEW：<strong>自分の手番中なら、チップを置いたカードを何度でもクリックして拡大表示できる</strong><br>
    ✅ NEW：<strong>次のプレイヤーが「カードを移動（並びを変える）」するまでは、前のプレイヤーも置きなおし（並び替え）可能</strong><br>
    ✅ NEW：<strong>全員のチップがなくなったターンの最後の移動後、左右端が大小アニメ→クリックで一斉公開（1秒刻み）</strong><br>
    ✅ NEW：<strong>左右端クリックで公開に入る直前に、カード上のチップを全消去</strong><br>
    ✅ ★今回追加：<strong>全員のチップがなくなったターンで、最後のプレイヤーが右上円に入れて手番終了した場合も、左右端が大小アニメ→クリックで公開</strong>
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<!-- ✅ ローカル拡大表示（表） -->
<div id="zoomBackdrop" class="zoom-backdrop hidden" aria-modal="true" role="dialog">
  <div id="zoomCard" class="zoom-card"></div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, get, update, onValue, remove, runTransaction
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

/* ▼ Firebase 設定 */
const firebaseConfig = {
  apiKey: "AIzaSyDUP1foVQnitM45do_UtYLkcc9gvgQC-xw",
  authDomain: "timebomb-3b0c7.firebaseapp.com",
  databaseURL: "https://timebomb-3b0c7-default-rtdb.firebaseio.com",
  projectId: "timebomb-3b0c7",
  storageBucket: "timebomb-3b0c7.firebasestorage.app",
  messagingSenderId: "532935786630",
  appId: "1:532935786630:web:ef1f97c862bfaad67d1107",
  measurementId: "G-K8NRR8K64Y"
};
const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

/* ✅ 確実にスクロール禁止（モバイルも含む） */
function lockScroll(){
  const prevent = (e) => { e.preventDefault(); };
  window.addEventListener('wheel', prevent, { passive:false });
  window.addEventListener('touchmove', prevent, { passive:false });
  window.addEventListener('keydown', (e) => {
    const keys = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','PageUp','PageDown','Home','End',' '];
    if (keys.includes(e.key)) e.preventDefault();
  }, { passive:false });
}
lockScroll();

/* ★ userId をタブ単位で固定（タブごとに別ID） */
const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

/* =========================
   ✅ チップ色（6色・重複しないように割当）
   ========================= */
const CHIP_COLORS = [
  { key:'red',   bg:'#ef4444', fg:'#ffffff' },
  { key:'blue',  bg:'#3b82f6', fg:'#ffffff' },
  { key:'green', bg:'#22c55e', fg:'#ffffff' },
  { key:'pink',  bg:'#ec4899', fg:'#ffffff' },
  { key:'black', bg:'#111827', fg:'#ffffff' },
  { key:'white', bg:'#ffffff', fg:'#374151' }
];

function pickUniqueChipColor(usedKeys){
  const available = CHIP_COLORS.filter(c => !usedKeys.has(c.key));
  const pool = available.length ? available : CHIP_COLORS;
  const c = pool[Math.floor(Math.random() * pool.length)];
  return c.key;
}
function chipStyleFromKey(key){
  const c = CHIP_COLORS.find(x => x.key === key) || CHIP_COLORS[0];
  return { bg: c.bg, fg: c.fg };
}

/* ✅ 画像名：zi + 数字(or X) + .jpg */
function cardImageUrl(label){
  return `zi${String(label)}.jpg`;
}

/* ✅ 中央横一列カード：基本は裏向き（ziziura.jpg）
   - ただし X カードだけは裏も表と同じ（ziX.jpg）
   - NEW: 公開フェーズ（revealPhase）中は、時間経過で表になる */
function centerRowCardBgUrl(label, { faceUp=false } = {}){
  if (faceUp) return cardImageUrl(label);
  return (String(label) === 'X') ? cardImageUrl('X') : 'ziziura.jpg';
}

/* ▼ 状態 */
const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  room: {},
  centerCards: [],
  helpCards: [],
  chipPlacements: {},
  circleChips: {},
  game: null,
  players: []
};

const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const topRightCircle = document.getElementById('topRightCircle');

const hostSelectingPop = document.getElementById('hostSelectingPop');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

/* ✅ 新：プレイヤーライン */
const playerLinesWrap = document.getElementById('playerLinesWrap');
const playerLineTop = document.getElementById('playerLineTop');
const playerLineBottom = document.getElementById('playerLineBottom');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

const centerRowWrap = document.getElementById('centerRowWrap');
const centerRowEl = document.getElementById('centerRow');
const insertMarkerEl = document.getElementById('insertMarker');

const zoomBackdrop = document.getElementById('zoomBackdrop');
const zoomCardEl = document.getElementById('zoomCard');

/* =========================================================
   ✅ 「拡大1.2秒 → 消えてから移動可」のローカル制御
   ========================================================= */
let moveUnlockAtMs = 0;
let moveAllowedCardId = null;
let zoomForced = false;

function lockMoveFor(ms, cardId){
  moveUnlockAtMs = Date.now() + ms;
  moveAllowedCardId = String(cardId || '');
}
function isMoveUnlocked(){
  return Date.now() >= (moveUnlockAtMs || 0);
}

/* =========================
   ✅ ローカル「カード表」ズーム表示
   ========================= */
let zoomAutoTimer = null;
function openZoom(label, { autoCloseMs = null, force = false } = {}){
  if (!label) return;
  if (zoomAutoTimer){ clearTimeout(zoomAutoTimer); zoomAutoTimer = null; }

  zoomForced = !!force;

  zoomCardEl.style.backgroundImage = `url('${cardImageUrl(label)}')`;
  zoomBackdrop.classList.remove('hidden');

  if (typeof autoCloseMs === 'number'){
    zoomAutoTimer = setTimeout(() => {
      closeZoom();
    }, autoCloseMs);
  }
}
function closeZoom(){
  if (zoomAutoTimer){ clearTimeout(zoomAutoTimer); zoomAutoTimer = null; }
  zoomBackdrop.classList.add('hidden');
  zoomForced = false;
}
zoomBackdrop.addEventListener('click', (e) => {
  if (e.target !== zoomBackdrop) return;
  if (zoomForced) return;
  closeZoom();
});

/* =========================
   ✅ NEW：公開（リビール）進行のローカルTicker
   ========================= */
let revealTicker = null;

function isRevealActive(){
  const rp = state.game?.revealPhase || null;
  return !!(rp && rp.active);
}
function revealChosen(){
  const rp = state.game?.revealPhase || null;
  return (rp && rp.active && rp.chosen) ? String(rp.chosen) : null;
}
function revealStartedAt(){
  const rp = state.game?.revealPhase || null;
  return (rp && rp.active && typeof rp.startedAt === 'number') ? rp.startedAt : null;
}
function ensureRevealTicker(){
  if (revealTicker) return;
  revealTicker = setInterval(() => {
    if (!centerRowWrap.classList.contains('hidden')) renderCenterRow();
    const dir = revealChosen();
    const st = revealStartedAt();
    const n = (state.centerCards || []).filter(Boolean).length;
    if (!dir || !st || n <= 0) return;

    const endMs = st + (n-1) * 1000 + 1500;
    if (Date.now() >= endMs){
      clearInterval(revealTicker);
      revealTicker = null;
      if (!centerRowWrap.classList.contains('hidden')) renderCenterRow();
    }
  }, 120);
}
function stopRevealTicker(){
  if (!revealTicker) return;
  clearInterval(revealTicker);
  revealTicker = null;
}

/* =========================
   ✅ Helpカード定義（11枚：1〜10とX）
   ========================= */
const DEFAULT_HELP_CARDS = [
  ...Array.from({length:10}).map((_,i)=>( {
    label: String(i+1),
    enabled: (i+1 !== 10)
  })),
  { label: 'X', enabled: false }
];
const TOGGLEABLE_LABELS = new Set(['10','X']);

function normalizeHelpCards(raw){
  const base = DEFAULT_HELP_CARDS.map(x => ({...x}));
  if (!raw) return base;
  const arr = Array.isArray(raw) ? raw : Object.values(raw);
  const map = new Map(arr.filter(Boolean).map(x => [String(x.label), !!x.enabled]));
  return base.map(b => ({
    label: b.label,
    enabled: map.has(b.label) ? map.get(b.label) : b.enabled
  }));
}

function shuffleInPlace(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function renderHelpList(){
  helpBody.innerHTML = '';
  const grid = document.createElement('div');
  grid.className = 'help-grid';

  const cards = (state.helpCards && state.helpCards.length) ? state.helpCards : DEFAULT_HELP_CARDS;

  cards.forEach(c => {
    const el = document.createElement('div');
    el.className = 'help-card';
    el.textContent = c.label;
    el.style.backgroundImage = `url('${cardImageUrl(c.label)}')`;
    el.title = c.label;

    if (!c.enabled) el.classList.add('dimmed');

    if (TOGGLEABLE_LABELS.has(c.label) && state.isHost){
      el.classList.add('host-toggle');
      el.title = `${c.label}（クリックで有効/無効）`;
      el.addEventListener('click', async () => {
        if (!state.roomCode) return;
        const next = cards.map(x => (x.label === c.label ? ({...x, enabled: !x.enabled}) : x));
        await set(ref(db, `rooms/${state.roomCode}/helpCards`), next);
      });
    }

    grid.appendChild(el);
  });

  helpBody.appendChild(grid);
}

function openHelp(){
  renderHelpList();
  helpBackdrop.classList.remove('hidden');
}
function closeHelp(){
  helpBackdrop.classList.add('hidden');
}
helpBtn.addEventListener('click', () => {
  if (joinBox.classList.contains('hidden')) openHelp();
});
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => {
  if (e.target === helpBackdrop) closeHelp();
});

let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;

/* =========================
   ★ 並び替えドラッグ状態（タッチ対応版）
   ========================= */
let draggingId = null;
let draggingFromIndex = -1;
let insertIndex = null;
let frozenSizing = null;
let rafPending = false;
let latestDragClientX = null;

let dragPointerId = null;
let dragFloatEl = null;
let dragOffsetX = 0;
let dragOffsetY = 0;
let isCommitting = false;
let dragSourceEl = null;

let pendingCardDown = null;

/* =========================
   ✅ チップドラッグ状態
   ========================= */
let chipDragging = null;
let chipPointerId = null;
let chipFloatEl = null;
let chipDragOffsetX = 0;
let chipDragOffsetY = 0;
let chipHoverCardId = null;

let chipHoverInCircle = false;

let chipLastClientX = null;
let chipLastClientY = null;

let circlePushRaf = false;
let circlePushRafId = null;
let circlePushQueued = null;
let circlePushLastCommitAt = 0;
let circleChipOptimisticUntil = {}; // { chipKey: expiresAtMs }

function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

/* =========================
   ✅ ゲーム手番：購読
   ========================= */
function subscribeGame(){
  const gRef = ref(db, `rooms/${state.roomCode}/game`);
  onValue(gRef, snap => {
    state.game = snap.val() || null;

    if (revealChosen() && revealStartedAt()){
      ensureRevealTicker();
    } else {
      if (!revealChosen()) {
        stopRevealTicker();
      }
    }

    const lp = state.game?.lastPlacement || null;
    if (state.game?.started && state.game?.turnPlayerId === state.userId && state.game?.turnPlaced){
      if (lp && lp.playerId === state.userId && lp.cardId && lp.cardId !== '__circle__'){
        moveAllowedCardId = String(lp.cardId);
      }
    }

    renderPlayerLines(state.players || []);
    if (!centerRowWrap.classList.contains('hidden')) renderCenterRow();
    renderCircleChips();
  });
}

function isMyTurn(){
  return !!(state.game && state.game.started && state.game.turnPlayerId === state.userId);
}
function canCurrentTurnPlace(){
  return !!(state.game && state.game.started && !state.game.turnPlaced);
}

function isActionsLockedByReveal(){
  const rp = state.game?.revealPhase || null;
  return !!(rp && rp.active && (rp.chosen || rp.startedAt));
}
function myPlacedCardIdThisTurn(){
  const lp = state.game?.lastPlacement;
  if (!lp) return null;
  if (lp.playerId !== state.userId) return null;
  if (String(lp.cardId) === '__circle__') return null;
  return String(lp.cardId);
}

function canRedoPrevReorder(cardId){
  const g = state.game;
  if (!g || !g.started) return false;
  if (isActionsLockedByReveal()) return false;

  const lr = g.lastReorder || null;
  if (!lr) return false;
  if (String(lr.playerId) !== String(state.userId)) return false;
  const ts = Number(g.turnSeq || 0);
  const lts = Number(lr.turnSeq || 0);
  if (ts !== (lts + 1)) return false;
  return String(lr.cardId) === String(cardId);
}

function canDragReorderNowForCard(cardId){
  if (!(state.game && state.game.started)) return false;
  if (isActionsLockedByReveal()) return false;

  if (canRedoPrevReorder(cardId)) return true;

  if (!isMyTurn()) return false;
  if (!state.game.turnPlaced) return false;

  if (!isMoveUnlocked()) return false;

  const allowed = (moveAllowedCardId || myPlacedCardIdThisTurn());
  if (!allowed) return false;

  return String(cardId) === String(allowed);
}

function canIPlaceChipNow(info){
  if (!info) return false;
  if (!state.roomCode) return false;
  if (isActionsLockedByReveal()) return false;
  if (!isMyTurn()) return false;
  if (!canCurrentTurnPlace()) return false;
  if (info.ownerId !== state.userId) return false;
  return true;
}

/* =========================
   ✅ チップ配置：DB購読
   ========================= */
function subscribeChipPlacements(){
  const cpRef = ref(db, `rooms/${state.roomCode}/chipPlacements`);
  onValue(cpRef, snap => {
    const v = snap.val() || {};
    state.chipPlacements = v;
    if (!centerRowWrap.classList.contains('hidden')) renderCenterRow();
    if (draggingId && dragFloatEl){
      const c = (state.centerCards || []).find(x => x && x.id === draggingId);
      if (c) renderCardChipStack(dragFloatEl, c.id);
    }
  });
}

/* =========================
   ✅ 右上円のチップ溜め：DB購読
   ========================= */
function subscribeCircleChips(){
  const cRef = ref(db, `rooms/${state.roomCode}/circleChips`);
  onValue(cRef, snap => {
    state.circleChips = snap.val() || {};
    renderCircleChips();
  });
}

function clearCircleChipsDom(){
  topRightCircle.querySelectorAll('.circle-chip').forEach(el => el.remove());
}

function circleChipActiveKeySet(){
  const set = new Set();
  for (const p of (state.players || [])){
    if (!p || !p.id) continue;
    const used = (Array.isArray(p.chipUsed) && p.chipUsed.length === 4) ? p.chipUsed : [false,false,false,false];
    for (let idx0=0; idx0<4; idx0++){
      if (used[idx0]) set.add(`${p.id}_${idx0+1}`);
    }
  }
  return set;
}

function circleChipRenderableKeySet(){
  const set = circleChipActiveKeySet();
  const now = Date.now();

  for (const [k, untilMs] of Object.entries(circleChipOptimisticUntil || {})){
    if (typeof untilMs !== 'number' || untilMs <= now){
      delete circleChipOptimisticUntil[k];
      continue;
    }
    set.add(String(k));
  }

  return set;
}
function renderCircleChips(){
  if (topRightCircle.classList.contains('hidden')) return;
  clearCircleChipsDom();

  const rect = topRightCircle.getBoundingClientRect();
  const size = Math.min(rect.width, rect.height);
  const chipR = 13;
  const margin = 6;
  const maxR = (size/2) - chipR - margin;

  const activeKeys = circleChipRenderableKeySet();
  const items = Object.entries(state.circleChips || {})
    .map(([k,v]) => ({ key:k, ...(v||{}) }))
    .filter(x => x && x.ownerId && x.type && typeof x.x === 'number' && typeof x.y === 'number')
    .filter(x => activeKeys.has(String(x.key)))
    .sort((a,b)=> (a.placedAt||0) - (b.placedAt||0));

  for (const it of items){
    const { bg, fg } = chipStyleFromKey(it.colorKey || 'red');
    const el = document.createElement('div');
    el.className = 'circle-chip';
    el.style.background = bg;
    el.style.color = fg;
    el.style.borderColor = ((it.colorKey || '') === 'white') ? 'rgba(0,0,0,.35)' : 'rgba(0,0,0,.25)';
    el.appendChild(makeChipShapeEl(Number(it.type) || 1));
    const x = clamp(it.x, -maxR, maxR);
    const y = clamp(it.y, -maxR, maxR);

    const left = (rect.width/2) + x - chipR;
    const top  = (rect.height/2) + y - chipR;
    el.style.left = `${left}px`;
    el.style.top  = `${top}px`;

    topRightCircle.appendChild(el);
  }
}

async function ensureChipUsedInitializedForSeat(seatIndex){
  if (!state.roomCode || !seatIndex) return;
  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  const snap = await get(tRef);
  const t = snap.val();
  if (!t) return;

  const cu = t.chipUsed;
  const ok = Array.isArray(cu) && cu.length === 4;
  if (!ok){
    await update(tRef, { chipUsed: [false,false,false,false] });
  }
}

async function commitChipPlacementAndMarkTurnPlaced(cardObj, info){
  if (!state.roomCode) return;

  const baseRef = ref(db, `rooms/${state.roomCode}`);
  const key = `${info.ownerId}_${info.type}`;
  const idx0 = (Number(info.type) || 1) - 1;

  const patch = {};
  patch[`chipPlacements/${cardObj.id}/${key}`] = {
    ownerId: info.ownerId,
    type: info.type,
    colorKey: info.colorKey,
    placedAt: Date.now()
  };

  if (info.seatIndex){
    patch[`tables/${info.seatIndex}/chipUsed/${idx0}`] = true;
  }

  patch[`game/turnPlaced`] = true;
  patch[`game/lastPlacement`] = {
    playerId: state.userId,
    cardId: cardObj.id,
    label: String(cardObj.label ?? ''),
    at: Date.now()
  };

  await update(baseRef, patch);
}

/* =========================
   ✅ 右上円：幾何
   ========================= */
function circleGeom(){
  const r = topRightCircle.getBoundingClientRect();
  const cx = r.left + r.width/2;
  const cy = r.top + r.height/2;
  const radius = Math.min(r.width, r.height)/2;
  return { rect:r, cx, cy, radius };
}
function pointInsideCircle(clientX, clientY){
  if (topRightCircle.classList.contains('hidden')) return false;
  const { cx, cy, radius } = circleGeom();
  const dx = clientX - cx;
  const dy = clientY - cy;
  return (dx*dx + dy*dy) <= Math.pow(radius - 4, 2);
}
function updateCircleHover(x,y){
  if (chipDragging){
    const dragCenter = dragChipCenterFromClient(x, y);
    chipHoverInCircle = pointInsideCircle(dragCenter.x, dragCenter.y);
    return;
  }
  chipHoverInCircle = pointInsideCircle(x,y);
}

/* =========================================================
   ✅ 円内チップ「押し出し」物理（吸い寄せ禁止）
   ========================================================= */
function circleParams(){
  const g = circleGeom();
  const chipR = 13;
  const margin = 6;
  const maxR = (Math.min(g.rect.width, g.rect.height)/2) - chipR - margin;
  return { g, chipR, margin, maxR };
}

function dragChipCenterFromClient(clientX, clientY){
  const left = clientX - chipDragOffsetX;
  const top  = clientY - chipDragOffsetY;
  return { x: left + 13, y: top + 13 };
}

function getCircleChipsAsArray(){
  const activeKeys = circleChipRenderableKeySet();
  return Object.entries(state.circleChips || {})
    .map(([key,val]) => ({ key, ...(val||{}) }))
    .filter(x => x && typeof x.x === 'number' && typeof x.y === 'number')
    .filter(x => activeKeys.has(String(x.key)));
}

function clampToCircle(x, y, maxR){
  const rr = Math.hypot(x,y) || 0.000001;
  if (rr <= maxR) return { x, y };
  const s = maxR / rr;
  return { x: x*s, y: y*s };
}

function separationUnit(dx, dy, fallbackAngle = 0){
  const d = Math.hypot(dx, dy);
  if (d > 0.0001){
    return { nx: dx / d, ny: dy / d, d };
  }
  return { nx: Math.cos(fallbackAngle), ny: Math.sin(fallbackAngle), d: 0.000001 };
}

function separatePair(a, b, minDist){
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  const fallbackAngle = ((a.x + b.x + a.y + b.y) * 0.17);
  const { nx, ny, d } = separationUnit(dx, dy, fallbackAngle);
  if (d >= minDist) return false;

  const overlap = (minDist - d);

  const push = overlap * 0.5;
  a.x += nx * push;
  a.y += ny * push;
  b.x -= nx * push;
  b.y -= ny * push;
  return true;
}

function applyDragPushImpulse(chips, dragCenter, dragDir, params){
  const { g, chipR, maxR } = params;
  const minDist = chipR*2 + 1.5;

  let any = false;

  for (let i=0; i<chips.length; i++){
    const c = chips[i];
    const cx = g.cx + c.x;
    const cy = g.cy + c.y;

    const dx = cx - dragCenter.x;
    const dy = cy - dragCenter.y;
    const fallbackAngle = Math.atan2(c.y, c.x) || (i * 0.9);
    const { nx, ny, d } = separationUnit(dx, dy, fallbackAngle);

    if (d < minDist){
      const overlap = (minDist - d);
      const push = overlap + 0.8;

      c.x += nx * push;
      c.y += ny * push;

      const clamped = clampToCircle(c.x, c.y, maxR);
      c.x = clamped.x; c.y = clamped.y;

      any = true;
    }
  }
  return any;
}

function relaxCircleOverlaps(chips, params){
  const { maxR, chipR } = params;
  const minDist = chipR*2 + 1.5;

  let moved = false;
  for (let iter=0; iter<10; iter++){
    let any = false;
    for (let i=0; i<chips.length; i++){
      for (let j=i+1; j<chips.length; j++){
        const a = chips[i], b = chips[j];
        if (separatePair(a, b, minDist)) any = true;
      }
    }
    for (const c of chips){
      const clamped = clampToCircle(c.x, c.y, maxR);
      c.x = clamped.x; c.y = clamped.y;
    }
    if (any) moved = true;
    if (!any) break;
  }
  return moved;
}

function clearPendingCirclePushCommits(){
  if (circlePushRafId !== null){
    try { cancelAnimationFrame(circlePushRafId); } catch {}
  }
  circlePushRaf = false;
  circlePushRafId = null;
  circlePushQueued = null;
  circleChipOptimisticUntil = {};
}

function scheduleCommitCirclePush(patch){
  if (!patch || Object.keys(patch).length === 0) return;

  circlePushQueued = { ...(circlePushQueued || {}), ...patch };

  if (circlePushRaf) return;
  circlePushRaf = true;

  circlePushRafId = requestAnimationFrame(async () => {
    circlePushRaf = false;
    circlePushRafId = null;

    const now = performance.now();
    if (now - circlePushLastCommitAt < 60){
      scheduleCommitCirclePush({});
      return;
    }

    const toSend = circlePushQueued;
    circlePushQueued = null;
    circlePushLastCommitAt = now;

    if (!state.roomCode) return;
    try{
      await update(ref(db, `rooms/${state.roomCode}/circleChips`), toSend);
    } catch {}
  });
}

function resolveCirclePushWhileDragging(clientX, clientY){
  if (!chipDragging) return;
  if (!state.roomCode) return;
  if (topRightCircle.classList.contains("hidden")) return;

  const params = circleParams();
  const dragCenter = dragChipCenterFromClient(clientX, clientY);
  if (!pointInsideCircle(dragCenter.x, dragCenter.y)) return;

  const prevX = (chipLastClientX ?? clientX);
  const prevY = (chipLastClientY ?? clientY);
  const dragDir = { x: clientX - prevX, y: clientY - prevY };

  const draggingKey = `${chipDragging.ownerId}_${chipDragging.type}`;
  const chips = getCircleChipsAsArray().filter(c => c.key !== draggingKey);
  if (!chips.length) return;

  const hit = applyDragPushImpulse(chips, dragCenter, dragDir, params);
  const relaxed = relaxCircleOverlaps(chips, params);
  if (!hit && !relaxed) return;

  const patch = {};
  for (const c of chips){
    const old = state.circleChips?.[c.key];
    if (!old) continue;
    const dx = (c.x - (old.x ?? 0));
    const dy = (c.y - (old.y ?? 0));
    if ((dx*dx + dy*dy) > 0.3){
      patch[c.key] = { ...old, x: c.x, y: c.y };
    }
  }
  scheduleCommitCirclePush(patch);
}

/* =========================================================
   ✅ NEW：全員のチップが「タグ上からなくなった」判定
   ========================================================= */
async function areAllPlayersOutOfChips(){
  if (!state.roomCode) return false;
  const snap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = snap.val() || {};
  const seated = Object.values(tables).filter(t => t && t.playerId);
  if (!seated.length) return false;

  for (const t of seated){
    const cu = (Array.isArray(t.chipUsed) && t.chipUsed.length === 4) ? t.chipUsed : [false,false,false,false];
    const allUsed = cu.every(x => !!x);
    if (!allUsed) return false;
  }
  return true;
}

/* =========================================================
   ✅ NEW：公開フェーズ開始（左右端パルス → 誰かが選ぶ）
   ========================================================= */
async function startRevealPhaseIfPossible(expectedTurnSeq){
  if (!state.roomCode) return false;

  const g = state.game;
  if (g?.revealPhase?.active) return true;

  const allOut = await areAllPlayersOutOfChips();
  if (!allOut) return false;

  const gRef = ref(db, `rooms/${state.roomCode}/game`);
  await runTransaction(gRef, (gg) => {
    if (!gg || !gg.started) return gg;
    if (gg.turnSeq !== expectedTurnSeq) return gg;

    if (gg.revealPhase && gg.revealPhase.active) return gg;

    return {
      ...gg,
      revealPhase: {
        active: true,
        chosen: null,
        chosenBy: null,
        chosenAt: null,
        startedAt: null
      }
    };
  });

  return true;
}

/* =========================================================
   ✅ ★重要変更：左右どちらから公開するか（誰かがクリック）
   ① chosen だけ決める（startedAt はまだ入れない）
   ② chipPlacements を null（=カード上のチップ全消去）
   ③ startedAt を入れて公開開始（各画面が ticker で表にする）
   ========================================================= */
async function chooseRevealDirection(dir){
  if (!state.roomCode) return;
  if (dir !== 'left' && dir !== 'right') return;

  const now = Date.now();
  const gRef = ref(db, `rooms/${state.roomCode}/game`);

  // ① 最初の1人だけ chosen を確定（startedAtはまだ入れない）
  //    ★同時に lastPlacement を消して「最後のターンのチップ大小アニメ」を即停止
  const tx = await runTransaction(gRef, (g) => {
    if (!g || !g.started) return g;
    if (!g.revealPhase || !g.revealPhase.active) return g;
    if (g.revealPhase.chosen) return g;

    return {
      ...g,
      lastPlacement: null, // ★追加：これで turn-pulsing が止まる
      revealPhase: {
        ...g.revealPhase,
        chosen: dir,
        chosenBy: state.userId,
        chosenAt: now,
        startedAt: null
      }
    };
  });

  if (!tx.committed) return;

  // ② 公開アクション直前：カード上のチップを全消去
  await set(ref(db, `rooms/${state.roomCode}/chipPlacements`), null);

  // ③ startedAt を入れて公開開始
  await update(ref(db, `rooms/${state.roomCode}`), {
    [`game/revealPhase/startedAt`]: Date.now()
  });
}


/* =========================
   ✅ 次の手番へ
   ========================= */
async function advanceTurnIfStillMyTurn(expectedTurnSeq, movedCardIdForLastReorder = null){
  if (!state.roomCode) return;
  const gRef = ref(db, `rooms/${state.roomCode}/game`);
  await runTransaction(gRef, (g) => {
    if (!g || !g.started) return g;
    if (g.turnPlayerId !== state.userId) return g;
    if (g.turnSeq !== expectedTurnSeq) return g;
    if (!Array.isArray(g.playerOrder) || g.playerOrder.length === 0) return g;

    const n = g.playerOrder.length;
    const nextIndex = (Number(g.turnIndex || 0) + 1) % n;

    const next = {
      ...g,
      turnIndex: nextIndex,
      turnPlayerId: g.playerOrder[nextIndex],
      turnPlaced: false,
      turnSeq: Number(g.turnSeq || 0) + 1,
      lastPlacement: null
    };

    if (movedCardIdForLastReorder){
      next.lastReorder = {
        playerId: state.userId,
        cardId: String(movedCardIdForLastReorder),
        at: Date.now(),
        turnSeq: Number(g.turnSeq || 0)
      };
    }
    return next;
  });

  moveUnlockAtMs = 0;
  moveAllowedCardId = null;
  zoomForced = false;
  closeZoom();
}

async function endTurnByReorderOrStartReveal(expectedTurnSeq, movedCardId){
  const startedReveal = await startRevealPhaseIfPossible(expectedTurnSeq);
  if (startedReveal) {
    moveUnlockAtMs = 0;
    moveAllowedCardId = null;
    zoomForced = false;
    closeZoom();
    if (!centerRowWrap.classList.contains('hidden')) renderCenterRow();
    return;
  }
  await advanceTurnIfStillMyTurn(expectedTurnSeq, movedCardId);
}

/* =========================
   ✅ カード上のチップ描画
   ========================= */
function makeChipShapeEl(type){
  const shape = document.createElement('span');
  shape.className = `chip-shape shape-${type}`;
  if (type === 3){
    const tri = document.createElement('span');
    tri.className = 'tri';
    shape.appendChild(tri);
  }
  if (type === 4){
    for (let k=0;k<4;k++){
      const s = document.createElement('span');
      shape.appendChild(s);
    }
  }
  return shape;
}

function renderCardChipStack(cardEl, cardId){
  cardEl.querySelectorAll('.card-chip-stack').forEach(x => x.remove());

  const obj = (state.chipPlacements && state.chipPlacements[cardId]) ? state.chipPlacements[cardId] : null;
  if (!obj) return;

  const items = Object.values(obj).filter(Boolean);
  if (!items.length) return;

  items.sort((a,b)=> (a.placedAt||0) - (b.placedAt||0));

  const stack = document.createElement('div');
  stack.className = 'card-chip-stack';

  const lp = state.game?.lastPlacement || null;
  const turnPid = state.game?.turnPlayerId || null;

  items.forEach(it => {
    const { bg, fg } = chipStyleFromKey(it.colorKey || 'red');
    const chip = document.createElement('div');
    chip.className = 'placed-chip';
    chip.style.background = bg;
    chip.style.color = fg;
    chip.style.borderColor = ((it.colorKey || '') === 'white') ? 'rgba(0,0,0,.35)' : 'rgba(0,0,0,.25)';
    chip.appendChild(makeChipShapeEl(Number(it.type) || 1));

    if (turnPid && lp && state.game?.started && String(lp.cardId) === String(cardId) && lp.playerId === turnPid){
      const near = Math.abs((it.placedAt||0) - (lp.at||0)) <= 5000;
      if (it.ownerId === turnPid && near) chip.classList.add('turn-pulsing');
    }

    stack.appendChild(chip);
  });

  cardEl.appendChild(stack);
}

function firstUnusedChipIndex0(chipUsed){
  const arr = (Array.isArray(chipUsed) && chipUsed.length === 4) ? chipUsed : [false,false,false,false];
  const idx = arr.findIndex(x => !x);
  return (idx < 0) ? -1 : idx;
}

/* =========================
   ✅ チップドラッグ：UI制御
   ========================= */
function ensureChipFloat(){
  if (chipFloatEl) return chipFloatEl;
  chipFloatEl = document.createElement('div');
  chipFloatEl.className = 'chip-float';
  document.body.appendChild(chipFloatEl);
  return chipFloatEl;
}
function removeChipFloat(){
  if (!chipFloatEl) return;
  chipFloatEl.remove();
  chipFloatEl = null;
}
function moveChipFloat(clientX, clientY){
  if (!chipFloatEl) return;
  const x = clientX - chipDragOffsetX;
  const y = clientY - chipDragOffsetY;
  chipFloatEl.style.transform = `translate(${x}px, ${y}px)`;
}

function setChipDragHints(_on){}

function getCenterCardUnderPoint(x,y){
  const els = document.elementsFromPoint(x,y);
  const hit = els.find(el => el?.classList?.contains('center-card'));
  return hit || null;
}
function updateChipHover(x,y){
  const cardEl = getCenterCardUnderPoint(x,y);
  chipHoverCardId = cardEl ? (cardEl.dataset.id || null) : null;

  updateCircleHover(x,y);
}

function releaseChipPointerCapture(){
  const srcEl = chipDragging?.sourceEl;
  const pid = chipPointerId;
  if (!srcEl || pid == null) return;
  try{
    if (srcEl.hasPointerCapture?.(pid)) srcEl.releasePointerCapture(pid);
  } catch {}
}

function beginChipDrag(sourceDotEl, info, e){
  if (!info || !state.roomCode) return;
  if (draggingId) return;
  if (chipDragging) return;
  if (isActionsLockedByReveal()) return;
  if (e.pointerType === 'mouse' && e.button !== 0) return;

  if (!canIPlaceChipNow(info)) return;

  chipDragging = info;
  chipPointerId = e.pointerId;
  chipHoverCardId = null;
  chipHoverInCircle = false;

  chipLastClientX = e.clientX;
  chipLastClientY = e.clientY;

  sourceDotEl.classList.add('dragging-hide');

  const floatEl = ensureChipFloat();
  floatEl.innerHTML = '';
  const { bg, fg } = chipStyleFromKey(info.colorKey || 'red');
  floatEl.style.background = bg;
  floatEl.style.color = fg;
  floatEl.style.borderColor = ((info.colorKey || '') === 'white') ? 'rgba(0,0,0,.35)' : 'rgba(0,0,0,.25)';
  floatEl.appendChild(makeChipShapeEl(info.type));

  chipDragOffsetX = 13;
  chipDragOffsetY = 13;
  moveChipFloat(e.clientX, e.clientY);

  setChipDragHints(true);
  updateChipHover(e.clientX, e.clientY);

  try { sourceDotEl.setPointerCapture(chipPointerId); } catch {}
  document.documentElement.style.userSelect = 'none';
}

function cancelChipDrag(){
  if (!chipDragging) return;

  releaseChipPointerCapture();

  if (chipDragging.sourceEl){
    chipDragging.sourceEl.classList.remove('dragging-hide');
  }
  chipDragging = null;
  chipPointerId = null;
  chipHoverCardId = null;
  chipHoverInCircle = false;

  chipLastClientX = null;
  chipLastClientY = null;

  setChipDragHints(false);
  removeChipFloat();
  document.documentElement.style.userSelect = '';
}

async function commitChipToCircleMarkPlaced(info, clientX, clientY){
  if (!state.roomCode) return;

  const params = circleParams();
  const { g, maxR } = params;
  const dragCenter = dragChipCenterFromClient(clientX, clientY);

  let seedX = dragCenter.x - g.cx;
  let seedY = dragCenter.y - g.cy;
  const seeded = clampToCircle(seedX, seedY, maxR);
  seedX = seeded.x;
  seedY = seeded.y;

  const chipKey = `${info.ownerId}_${info.type}`;
  circleChipOptimisticUntil[chipKey] = Date.now() + 2500;
  const chips = getCircleChipsAsArray().filter(c => c.key !== chipKey);

  const chipR = 13;
  const minDist = chipR*2 + 1.5;
  for (const c of chips){
    const dx = c.x - seedX;
    const dy = c.y - seedY;
    const fallbackAngle = Math.atan2(c.y, c.x);
    const { nx, ny, d } = separationUnit(dx, dy, fallbackAngle);
    if (d < minDist){
      const overlap = (minDist - d) + 1.0;
      c.x += nx * overlap;
      c.y += ny * overlap;
      const clamped = clampToCircle(c.x, c.y, maxR);
      c.x = clamped.x;
      c.y = clamped.y;
    }
  }
  relaxCircleOverlaps(chips, params);

  const baseRef = ref(db, `rooms/${state.roomCode}`);
  const idx0 = (Number(info.type) || 1) - 1;

  const patch = {};
  for (const c of chips){
    const old = state.circleChips?.[c.key];
    if (!old) continue;
    patch[`circleChips/${c.key}`] = { ...old, x: c.x, y: c.y };
  }
  patch[`circleChips/${chipKey}`] = {
    ownerId: info.ownerId,
    type: info.type,
    colorKey: info.colorKey,
    x: seedX,
    y: seedY,
    placedAt: Date.now()
  };

  if (info.seatIndex){
    patch[`tables/${info.seatIndex}/chipUsed/${idx0}`] = true;
  }

  patch[`game/turnPlaced`] = true;
  patch[`game/lastPlacement`] = {
    playerId: state.userId,
    cardId: '__circle__',
    label: '',
    at: Date.now()
  };

  await update(baseRef, patch);
}

async function finishChipDrag(lastClientX, lastClientY){
  if (!chipDragging) return;

  const dropCardId = chipHoverCardId;
  const dropInCircle = !!chipHoverInCircle;
  const dragInfo = chipDragging;
  const srcEl = dragInfo.sourceEl;

  if (!dropCardId && !dropInCircle){
    cancelChipDrag();
    return;
  }

  if (!canIPlaceChipNow(dragInfo)){
    cancelChipDrag();
    return;
  }

  const myTurnSeq = Number(state.game?.turnSeq || 0);

  releaseChipPointerCapture();
  chipDragging = null;
  chipPointerId = null;
  chipHoverCardId = null;
  chipHoverInCircle = false;
  chipLastClientX = null;
  chipLastClientY = null;
  setChipDragHints(false);
  removeChipFloat();
  document.documentElement.style.userSelect = '';

  try{
    if (dropInCircle){
      await commitChipToCircleMarkPlaced(dragInfo, lastClientX, lastClientY);

      if (srcEl){
        srcEl.classList.remove('dragging-hide');
        srcEl.classList.add('used');
      }

      /* =========================================================
         ✅ ★今回の追加ポイント
         「全員のチップがなくなった」状態で、
         最後のプレイヤーが右上円に置いて手番終了した場合も
         左右端パルス→クリック（公開）へ入る
         ========================================================= */
      const startedReveal = await startRevealPhaseIfPossible(myTurnSeq);
      if (startedReveal){
        moveUnlockAtMs = 0;
        moveAllowedCardId = null;
        zoomForced = false;
        closeZoom();
        if (!centerRowWrap.classList.contains('hidden')) renderCenterRow();
        return;
      }

      await advanceTurnIfStillMyTurn(myTurnSeq, null);
      return;
    }

    const cardObj = (state.centerCards || []).find(x => x && x.id === dropCardId);
    if (!cardObj){
      if (srcEl) srcEl.classList.remove('dragging-hide');
      return;
    }

    lockMoveFor(1200, cardObj.id);

    await commitChipPlacementAndMarkTurnPlaced(cardObj, dragInfo);

    if (srcEl){
      srcEl.classList.remove('dragging-hide');
      srcEl.classList.add('used');
    }

    openZoom(String(cardObj.label ?? ''), { autoCloseMs: 1200, force: true });

  } catch (err) {
    if (srcEl) srcEl.classList.remove('dragging-hide');
    throw err;
  }
}

window.addEventListener('pointermove', (e) => {
  if (!chipDragging) return;
  if (chipPointerId !== null && e.pointerId !== chipPointerId) return;
  e.preventDefault();

  moveChipFloat(e.clientX, e.clientY);
  resolveCirclePushWhileDragging(e.clientX, e.clientY);
  updateChipHover(e.clientX, e.clientY);

  chipLastClientX = e.clientX;
  chipLastClientY = e.clientY;
}, { passive:false });

window.addEventListener('pointerup', async (e) => {
  if (!chipDragging) return;
  if (chipPointerId !== null && e.pointerId !== chipPointerId) return;
  e.preventDefault();
  await finishChipDrag(e.clientX, e.clientY);
}, { passive:false });

window.addEventListener('pointercancel', (e) => {
  if (!chipDragging) return;
  if (chipPointerId !== null && e.pointerId !== chipPointerId) return;
  cancelChipDrag();
}, { passive:false });

/* =========================
   ✅ 中央カードの自動サイズ
   ========================= */
function computeBaseSizing(){
  const wrapRect = centerRowWrap.getBoundingClientRect();
  const wrapW = wrapRect.width;

  const visibleCount = (state.centerCards || []).filter(Boolean).length;
  const count = Math.max(10, visibleCount || 0);

  const padX = 10;
  const padY = 10;

  const usable = Math.max(0, wrapW - padX*2);

  let gap = clamp(Math.floor(wrapW / 140), 3, 10);

  let cardW = (usable - gap*(count-1)) / count;
  cardW = clamp(Math.floor(cardW), 34, 90);

  gap = (count > 1) ? (usable - cardW*count) / (count-1) : 0;
  gap = clamp(Math.floor(gap), 0, 10);

  const cardH = Math.floor(cardW * 1.4);
  const font = clamp(Math.floor(cardW * 0.28), 10, 20);

  return { cardW, cardH, font, gap, padX, padY };
}

function applySizing(s){
  centerRowWrap.style.setProperty('--cc-w', `${s.cardW}px`);
  centerRowWrap.style.setProperty('--cc-h', `${s.cardH}px`);
  centerRowWrap.style.setProperty('--cc-font', `${s.font}px`);
  centerRowWrap.style.setProperty('--cc-gap', `${s.gap}px`);
  centerRowWrap.style.setProperty('--cc-padX', `${s.padX}px`);
  centerRowWrap.style.setProperty('--cc-padY', `${s.padY}px`);
  centerRowWrap.style.setProperty('--cc-insFactor', `0.95`);
}

function updateCenterCardSizing(){
  if (centerRowWrap.classList.contains('hidden')) return;

  if (draggingId && frozenSizing){
    applySizing(frozenSizing);
    return;
  }
  const s = computeBaseSizing();
  applySizing(s);
}

function updatePlayerLinesGeometry(){
  if (playerLinesWrap.classList.contains('hidden')) return;
  if (centerRowWrap.classList.contains('hidden')) return;

  const r = centerRowWrap.getBoundingClientRect();
  const centerY = r.top + r.height / 2;

  const offset = Math.max(90, Math.round((r.height / 2) + 70));

  const topY = centerY - offset;
  const bottomY = centerY + offset;

  playerLineTop.style.top = `${Math.round(topY)}px`;
  playerLineBottom.style.top = `${Math.round(bottomY)}px`;

  const w = Math.max(260, Math.min(920, Math.round(r.width - 24)));
  playerLineTop.style.width = `${w}px`;
  playerLineBottom.style.width = `${w}px`;
}

window.addEventListener('resize', () => {
  updateCenterCardSizing();
  updatePlayerLinesGeometry();
  if (!centerRowWrap.classList.contains('hidden')) renderCenterRow();
  renderPlayerLines(state.players || []);
  renderCircleChips();
});

const ro = new ResizeObserver(() => {
  updateCenterCardSizing();
  updatePlayerLinesGeometry();
  if (!centerRowWrap.classList.contains('hidden')) renderCenterRow();
  renderPlayerLines(state.players || []);
  renderCircleChips();
});
ro.observe(centerRowWrap);

function subscribeCenterCards(){
  const ccRef = ref(db, `rooms/${state.roomCode}/centerCards`);
  onValue(ccRef, snap => {
    const data = snap.val();
    const arr = Array.isArray(data) ? data : (data ? Object.values(data) : []);
    state.centerCards = arr.filter(Boolean);

    updateCenterCardSizing();
    renderCenterRow();
    updatePlayerLinesGeometry();
    renderPlayerLines(state.players || []);

    if (draggingId && dragFloatEl){
      const c = (state.centerCards || []).find(x => x && x.id === draggingId);
      if (c) renderCardChipStack(dragFloatEl, c.id);
    }
  });
}

function subscribeHelpCards(){
  const hcRef = ref(db, `rooms/${state.roomCode}/helpCards`);
  onValue(hcRef, snap => {
    state.helpCards = normalizeHelpCards(snap.val());
    if (!helpBackdrop.classList.contains('hidden')) renderHelpList();
  });
}

async function ensureHelpCardsInitialized(){
  if (!state.roomCode) return;
  const hcRef = ref(db, `rooms/${state.roomCode}/helpCards`);
  const snap = await get(hcRef);
  if (!snap.exists()){
    await set(hcRef, DEFAULT_HELP_CARDS);
  }
}

function hideInsertMarker(){
  insertMarkerEl.classList.remove('visible');
  insertMarkerEl.style.left = '-9999px';
}

function getStepPx(){
  const s = (draggingId && frozenSizing) ? frozenSizing : computeBaseSizing();
  return (s.cardW + s.gap);
}

function getRenderableCenterCards(){
  return (state.centerCards || []).filter(Boolean);
}

function applyVisualShift(){
  const visible = getRenderableCenterCards();

  if (!draggingId || typeof insertIndex !== 'number' || draggingFromIndex < 0){
    centerRowEl.classList.remove('dragging');
    centerRowEl.querySelectorAll('.center-card').forEach(el => { el.style.transform = ''; });
    return;
  }
  centerRowEl.classList.add('dragging');

  const step = getStepPx();
  const from = draggingFromIndex;
  const to = clamp(insertIndex, 0, visible.length);

  centerRowEl.querySelectorAll('.center-card').forEach(el => {
    const p = Number(el.dataset.index);
    let dx = 0;

    if (from < to){
      if (p > from && p < to) dx = -step;
    } else if (from > to){
      if (p >= to && p < from) dx = +step;
    }
    el.style.transform = dx ? `translateX(${dx}px)` : '';
  });
}

function getSlotElements(){
  return [...centerRowEl.querySelectorAll('.center-card, .center-ghost')];
}

function clampInsertIndex(idx){
  const slots = getSlotElements();
  const maxSlots = slots.length;
  if (maxSlots <= 1) return 0;
  return clamp(idx, 1, maxSlots - 1);
}

function getSlotBoundariesFromLayout(slots, rowRect){
  const boundaries = new Array(slots.length + 1);
  if (!slots.length) return boundaries;

  const rects = slots.map(el => el.getBoundingClientRect());

  boundaries[0] = rects[0].left;
  for (let i = 1; i < rects.length; i++){
    boundaries[i] = (rects[i-1].right + rects[i].left) / 2;
  }
  boundaries[slots.length] = rects[rects.length - 1].right;
  return boundaries;
}

function calcRawInsertIndexFromBoundaries(clientX, boundaries, slotCount){
  let raw = slotCount;
  for (let i = 0; i < slotCount; i++){
    if (clientX < boundaries[i+1]) { raw = i; break; }
  }
  return raw;
}

function getCardCenterXFromSlots(slots, startIdx, dir){
  let i = startIdx;
  while (i >= 0 && i < slots.length){
    const el = slots[i];
    if (el?.classList?.contains('center-card')){
      const r = el.getBoundingClientRect();
      return r.left + (r.width / 2);
    }
    i += dir;
  }
  return null;
}

function calcInsertIndexStepByStep(raw, prevInsertIndex, clientX, slots){
  const safeRaw = clampInsertIndex(raw);
  if (typeof prevInsertIndex !== 'number') return safeRaw;

  let idx = clampInsertIndex(prevInsertIndex);
  if (idx === safeRaw) return idx;

  const s = (draggingId && frozenSizing) ? frozenSizing : computeBaseSizing();
  const dragW = s.cardW || 0;
  const dragLeft = clientX - (dragW / 2);
  const dragRight = clientX + (dragW / 2);

  while (idx < safeRaw){
    if (idx >= slots.length - 1) break;

    const leftCardCenter = getCardCenterXFromSlots(slots, idx, -1);
    if (leftCardCenter == null) break;

    if (dragLeft >= leftCardCenter){
      idx += 1;
      continue;
    }
    break;
  }

  while (idx > safeRaw){
    if (idx <= 1) break;

    const rightCardCenter = getCardCenterXFromSlots(slots, idx - 1, +1);
    if (rightCardCenter == null) break;

    if (dragRight <= rightCardCenter){
      idx -= 1;
      continue;
    }
    break;
  }

  return clampInsertIndex(idx);
}

function calcInsertIndexFromClientX(clientX, prevInsertIndex){
  const slots = getSlotElements();
  if (slots.length === 0) return 0;

  const rowRect = centerRowEl.getBoundingClientRect();
  const boundaries = getSlotBoundariesFromLayout(slots, rowRect);

  const raw = calcRawInsertIndexFromBoundaries(clientX, boundaries, slots.length);
  return calcInsertIndexStepByStep(raw, prevInsertIndex, clientX, slots);
}

function updateInsertMarkerFromIndex(idx){
  if (!draggingId || typeof idx !== 'number') { hideInsertMarker(); return; }

  const slots = getSlotElements();
  const rowRect = centerRowEl.getBoundingClientRect();
  if (slots.length === 0) { hideInsertMarker(); return; }

  const boundaries = getSlotBoundariesFromLayout(slots, rowRect);

  const safeIdx = clampInsertIndex(idx);
  const bX = boundaries[clamp(safeIdx, 0, slots.length)];

  insertMarkerEl.classList.add('visible');
  const mRect = insertMarkerEl.getBoundingClientRect();
  const markerW = mRect.width || 0;

  const refSlot = slots[Math.min(Math.max(Math.min(safeIdx, slots.length-1), 0), slots.length-1)];
  const top = refSlot.getBoundingClientRect().top - rowRect.top;

  const left = (bX - rowRect.left) - markerW/2;

  insertMarkerEl.style.top = `${Math.max(0, top)}px`;
  insertMarkerEl.style.left = `${left}px`;
}

function scheduleDragOverUpdate(clientX){
  latestDragClientX = clientX;
  if (rafPending) return;
  rafPending = true;
  requestAnimationFrame(() => {
    rafPending = false;
    if (latestDragClientX === null) return;
    const idx = calcInsertIndexFromClientX(latestDragClientX, insertIndex);
    if (insertIndex !== idx){
      insertIndex = idx;
      updateInsertMarkerFromIndex(insertIndex);
      applyVisualShift();
    }
  });
}

function idsOf(arr){ return arr.map(x => String(x?.id ?? '')).join('|'); }

async function commitReorderAndMaybeEndTurn(newArr, changed, movedCardId){
  if (!state.roomCode) return;

  await set(ref(db, `rooms/${state.roomCode}/centerCards`), newArr);

  if (canRedoPrevReorder(movedCardId)) return;

  if (!changed) return;

  if (isActionsLockedByReveal()) return;

  const myTurnSeq = Number(state.game?.turnSeq || 0);

  const allowed = (moveAllowedCardId || myPlacedCardIdThisTurn());
  if (!allowed) return;
  if (!canDragReorderNowForCard(allowed)) return;

  await endTurnByReorderOrStartReveal(myTurnSeq, allowed);
}

function ensureDragFloat(){
  if (dragFloatEl) return dragFloatEl;
  dragFloatEl = document.createElement('div');
  dragFloatEl.className = 'drag-float';
  document.body.appendChild(dragFloatEl);
  return dragFloatEl;
}
function moveDragFloat(clientX, clientY){
  if (!dragFloatEl) return;
  const x = clientX - dragOffsetX;
  const y = clientY - dragOffsetY;
  dragFloatEl.style.transform = `translate(${x}px, ${y}px)`;
}
function dragCardCenterXFromPointer(clientX){
  const s = (draggingId && frozenSizing) ? frozenSizing : computeBaseSizing();
  return clientX - dragOffsetX + (s.cardW / 2);
}
function removeDragFloat(){
  if (!dragFloatEl) return;
  dragFloatEl.remove();
  dragFloatEl = null;
}
function syncDragFloatStyleFromCard(cardEl){
  if (!dragFloatEl || !cardEl) return;
  const cs = getComputedStyle(cardEl);
  dragFloatEl.style.width = cs.width;
  dragFloatEl.style.height = cs.height;
  dragFloatEl.style.borderRadius = cs.borderRadius;
  dragFloatEl.style.border = cs.border;
  dragFloatEl.style.background = cs.background;
  dragFloatEl.style.backgroundImage = cs.backgroundImage;
  dragFloatEl.style.backgroundSize = cs.backgroundSize;
  dragFloatEl.style.backgroundPosition = cs.backgroundPosition;
  dragFloatEl.style.backgroundRepeat = cs.backgroundRepeat;
  dragFloatEl.style.boxShadow = cs.boxShadow;
}

function beginDragFromCard(cardEl, cardObj, idx, clientX, clientY, pointerId){
  if (chipDragging) return;
  if (isActionsLockedByReveal()) return;

  if (!canDragReorderNowForCard(cardObj.id)) return;

  draggingId = cardObj.id;
  draggingFromIndex = idx;

  insertIndex = clampInsertIndex(idx);

  isCommitting = false;
  dragSourceEl = cardEl;

  frozenSizing = computeBaseSizing();
  updateCenterCardSizing();

  const rect = cardEl.getBoundingClientRect();
  dragOffsetX = clientX - rect.left;
  dragOffsetY = clientY - rect.top;

  const floatEl = ensureDragFloat();
  floatEl.textContent = String(cardObj.label ?? '');
  floatEl.style.backgroundImage = `url('${centerRowCardBgUrl(cardObj.label, { faceUp:false })}')`;
  syncDragFloatStyleFromCard(cardEl);
  renderCardChipStack(floatEl, cardObj.id);

  moveDragFloat(clientX, clientY);

  requestAnimationFrame(() => {
    renderCenterRow();
    updateInsertMarkerFromIndex(insertIndex);
    applyVisualShift();
  });

  dragPointerId = pointerId;
  try { cardEl.setPointerCapture(dragPointerId); } catch {}
  document.documentElement.style.userSelect = 'none';
}

function handleDraggingPointerMove(e){
  if (!draggingId) return;
  if (dragPointerId !== null && e.pointerId !== dragPointerId) return;
  e.preventDefault();
  moveDragFloat(e.clientX, e.clientY);
  scheduleDragOverUpdate(dragCardCenterXFromPointer(e.clientX));
}

async function handleDraggingPointerUp(e){
  if (!draggingId) return;
  if (dragPointerId !== null && e.pointerId !== dragPointerId) return;
  e.preventDefault();
  await finishDrag(dragCardCenterXFromPointer(e.clientX));
}

function handleDraggingPointerCancel(e){
  if (!draggingId) return;
  if (dragPointerId !== null && e.pointerId !== dragPointerId) return;
  cleanupDrag();
}

window.addEventListener('pointermove', handleDraggingPointerMove, { passive:false });
window.addEventListener('pointerup', handleDraggingPointerUp, { passive:false });
window.addEventListener('pointercancel', handleDraggingPointerCancel, { passive:false });

async function finishDrag(probeX){
  if (!draggingId || isCommitting) return;
  isCommitting = true;

  if (!canDragReorderNowForCard(draggingId)){
    cleanupDrag();
    return;
  }

  const fromId = draggingId;

  const rawIdx = (typeof insertIndex === 'number') ? insertIndex : calcInsertIndexFromClientX(probeX, insertIndex);
  const idx = clampInsertIndex(rawIdx);

  const visible = getRenderableCenterCards();
  const beforeIds = idsOf(visible);

  const fromIndex = visible.findIndex(x => x && x.id === fromId);
  if (fromIndex < 0){
    cleanupDrag();
    return;
  }

  const arr = [...visible];
  const [moved] = arr.splice(fromIndex, 1);

  let adjustedIndex = (fromIndex < idx) ? (idx - 1) : idx;

  const lenAfter = arr.length + 1;
  if (lenAfter >= 3){
    adjustedIndex = clamp(adjustedIndex, 1, lenAfter - 2);
  }

  arr.splice(adjustedIndex, 0, moved);

  const afterIds = idsOf(arr);
  const changed = (beforeIds !== afterIds);

  try{
    await commitReorderAndMaybeEndTurn(arr, changed, fromId);
  } finally {
    cleanupDrag();
  }
}
function cleanupDrag(){
  const prevPointerId = dragPointerId;

  draggingId = null;
  draggingFromIndex = -1;
  insertIndex = null;
  frozenSizing = null;
  rafPending = false;
  latestDragClientX = null;

  if (dragSourceEl && prevPointerId !== null && dragSourceEl.hasPointerCapture?.(prevPointerId)){
    try { dragSourceEl.releasePointerCapture(prevPointerId); } catch {}
  }
  dragPointerId = null;
  dragSourceEl = null;
  isCommitting = false;

  hideInsertMarker();
  removeDragFloat();
  document.documentElement.style.userSelect = '';

  updateCenterCardSizing();
  renderCenterRow();
  updatePlayerLinesGeometry();
  renderPlayerLines(state.players || []);
  applyVisualShift();
}

/* =========================
   ✅ クリックで表ズームできる条件
   ========================= */
function canClickZoomLastPlaced(cardId){
  const g = state.game;
  if (!g || !g.started) return false;
  if (isActionsLockedByReveal()) return false;

  const lp = g.lastPlacement;
  if (!lp || lp.playerId !== state.userId) return false;
  if (String(lp.cardId) !== String(cardId)) return false;
  if (g.turnPlayerId === state.userId) return false;
  if (g.turnPlaced) return false;
  return true;
}

function canClickZoomMyPlacedThisTurn(cardId){
  const g = state.game;
  if (!g || !g.started) return false;
  if (isActionsLockedByReveal()) return false;

  if (!isMyTurn()) return false;
  if (!g.turnPlaced) return false;
  const lp = g.lastPlacement;
  if (!lp || lp.playerId !== state.userId) return false;
  if (String(lp.cardId) === '__circle__') return false;
  return String(lp.cardId) === String(cardId);
}

function canChooseRevealOnCard(cardObj, idx, total){
  if (!cardObj) return false;
  const rp = state.game?.revealPhase || null;
  if (!rp || !rp.active) return false;
  if (rp.chosen) return false;
  if (total < 2) return false;
  return (idx === 0 || idx === total - 1);
}

function handleCenterCardClick(cardObj, idx, total){
  if (!cardObj) return;

  if (canChooseRevealOnCard(cardObj, idx, total)){
    const dir = (idx === 0) ? 'left' : 'right';
    chooseRevealDirection(dir);
    return;
  }

  const ok =
    canClickZoomLastPlaced(cardObj.id) ||
    canClickZoomMyPlacedThisTurn(cardObj.id);

  if (!ok) return;

  openZoom(String(cardObj.label ?? ''), { autoCloseMs: null, force: false });
}

function isCardFaceUpByReveal(idx, total){
  const dir = revealChosen();
  const st = revealStartedAt();
  if (!dir || !st) return false;

  const elapsed = Date.now() - st;
  if (elapsed < 0) return false;

  const stepIndex = (dir === 'left') ? idx : (total - 1 - idx);
  return elapsed >= (stepIndex * 1000);
}

function renderCenterRow(){
  updateCenterCardSizing();

  const kids = [...centerRowEl.children].filter(el => el.id !== 'insertMarker');
  kids.forEach(el => el.remove());

  const cards = getRenderableCenterCards();
  if (!cards.length) {
    insertIndex = null;
    hideInsertMarker();
    centerRowEl.classList.remove('dragging');
    return;
  }

  const rp = state.game?.revealPhase || null;
  const revealActive = !!(rp && rp.active);
  const revealDir = revealChosen();

  cards.forEach((c, idx) => {
    if (draggingId && c.id === draggingId){
      const ghost = document.createElement('div');
      ghost.className = 'center-ghost';
      ghost.dataset.id = c.id;
      ghost.dataset.index = String(idx);
      centerRowEl.appendChild(ghost);
      return;
    }

    const el = document.createElement('div');
    el.className = 'center-card';
    el.textContent = String(c.label ?? '');

    const faceUp = revealDir ? isCardFaceUpByReveal(idx, cards.length) : false;

    el.style.backgroundImage = `url('${centerRowCardBgUrl(c.label, { faceUp })}')`;
    el.dataset.id = c.id;
    el.dataset.index = String(idx);

    renderCardChipStack(el, c.id);

    if (revealActive && !revealDir && cards.length >= 2){
      if (idx === 0 || idx === cards.length - 1){
        el.classList.add('end-pulsing');
        el.style.cursor = 'pointer';
      }
    }

    el.addEventListener('pointerdown', (e) => {
      if (draggingId) return;
      if (chipDragging) return;
      if (e.pointerType === 'mouse' && e.button !== 0) return;

      const choosingReveal = canChooseRevealOnCard(c, idx, cards.length);
      if (choosingReveal){
        e.preventDefault();
        pendingCardDown = {
          cardEl: el,
          cardObj: c,
          idx,
          pointerId: e.pointerId,
          startX: e.clientX,
          startY: e.clientY,
          moved: false,
          dragOK: false,
          revealPick: true,
          total: cards.length
        };
        try { el.setPointerCapture(e.pointerId); } catch {}
        return;
      }

      const dragOK = canDragReorderNowForCard(c.id);

      const clickOK =
        canClickZoomLastPlaced(c.id) ||
        canClickZoomMyPlacedThisTurn(c.id);

      if (!dragOK && !clickOK) return;

      e.preventDefault();

      pendingCardDown = {
        cardEl: el,
        cardObj: c,
        idx,
        pointerId: e.pointerId,
        startX: e.clientX,
        startY: e.clientY,
        moved: false,
        dragOK,
        revealPick: false,
        total: cards.length
      };
      try { el.setPointerCapture(e.pointerId); } catch {}
    }, { passive:false });

    el.addEventListener('pointermove', (e) => {
      if (!pendingCardDown) return;
      if (pendingCardDown.pointerId !== e.pointerId) return;
      if (draggingId) return;

      if (!pendingCardDown.dragOK) return;

      const dx = e.clientX - pendingCardDown.startX;
      const dy = e.clientY - pendingCardDown.startY;
      const dist2 = dx*dx + dy*dy;

      if (!pendingCardDown.moved && dist2 >= (8*8)){
        pendingCardDown.moved = true;
        beginDragFromCard(
          pendingCardDown.cardEl,
          pendingCardDown.cardObj,
          pendingCardDown.idx,
          e.clientX, e.clientY,
          pendingCardDown.pointerId
        );
      }
    }, { passive:false });

    el.addEventListener('pointerup', (e) => {
      if (!pendingCardDown) return;
      if (pendingCardDown.pointerId !== e.pointerId) return;

      if (!pendingCardDown.moved && !draggingId){
        handleCenterCardClick(pendingCardDown.cardObj, pendingCardDown.idx, pendingCardDown.total);
      }
      pendingCardDown = null;
    }, { passive:false });

    el.addEventListener('pointercancel', (e) => {
      if (!pendingCardDown) return;
      if (pendingCardDown.pointerId !== e.pointerId) return;
      pendingCardDown = null;
    }, { passive:false });

    el.addEventListener('contextmenu', (e) => e.preventDefault());
    centerRowEl.appendChild(el);
  });

  if (draggingId && typeof insertIndex === 'number'){
    insertMarkerEl.classList.add('visible');
  } else {
    hideInsertMarker();
  }

  applyVisualShift();

  if (revealDir && revealStartedAt()){
    ensureRevealTicker();
  }
}

/* =========================
   以降：部屋/席/ホストなど
   ========================= */
function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }

  helpBtn.classList.add('visible');

  centerRowWrap.classList.remove('hidden');
  playerLinesWrap.classList.remove('hidden');

  updateCenterCardSizing();
  updatePlayerLinesGeometry();
  renderPlayerLines(state.players || []);
}

function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    syncSeatUI();
  });
}
function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, async snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();

    await ensureHelpCardsInitialized();
  });
}

const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  topRightCircle.classList.remove('hidden');

  await restoreSeatFromDB();

  await ensureHelpCardsInitialized();
  subscribeHelpCards();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeCenterCards();
  subscribeChipPlacements();
  subscribeCircleChips();
  subscribeGame();

  updateCenterCardSizing();
  updatePlayerLinesGeometry();
  syncSeatUI();

  renderCircleChips();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='COPY';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});

async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;

  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function getUsedChipColorKeys(){
  const snap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = snap.val() || {};
  const used = new Set();
  Object.values(tables).forEach(t => {
    if (t && t.playerId && t.chipColor) used.add(String(t.chipColor));
  });
  return used;
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';
      for(let i=2; i<=8; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });

          const used = await getUsedChipColorKeys();
          const myColor = pickUniqueChipColor(used);

          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, {
            playerId: state.userId,
            playerName: state.userName,
            chipColor: myColor,
            chipUsed: [false,false,false,false]
          });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');

          await ensureChipUsedInitializedForSeat(1);
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = '席を選択';

    const effectiveMax = maxPlayers || 8;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;

        const used = new Set();
        Object.values(tables).forEach(x => {
          if (x && x.playerId && x.chipColor) used.add(String(x.chipColor));
        });
        const myColor = pickUniqueChipColor(used);

        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, {
          playerId: state.userId,
          playerName: state.userName || '名無し',
          chipColor: myColor,
          chipUsed: [false,false,false,false]
        });
        state.seatedTable = i;
        seatPop.classList.add('hidden');

        await ensureChipUsedInitializedForSeat(i);
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex),
        chipColor: t.chipColor || null,
        chipUsed: t.chipUsed || [false,false,false,false]
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    state.players = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    if (mySeat){
      await ensureChipUsedInitializedForSeat(mySeat.seatIndex);
    }

    await syncSeatUI();
    updatePlayerLinesGeometry();
    renderPlayerLines(players);
  });
}

/* =========================================================
   ✅ ネームタグ配置
   ========================================================= */
function clearPlayerStacks(){
  playerLinesWrap.querySelectorAll('.player-stack').forEach(el => el.remove());
}

function rotatePlayersByMySeat(players){
  if (!players || players.length === 0) return [];
  const me = players.find(p => p.id === state.userId);
  if (!me) return [...players];
  const mySeat = Number(me.seatIndex);

  const idx = players.findIndex(p => Number(p.seatIndex) === mySeat);
  if (idx < 0) return [...players];
  return [...players.slice(idx), ...players.slice(0, idx)];
}

function getLayoutOrderIndices(n){
  switch (n){
    case 3: return { top:[1,2], bottom:[0] };
    case 4: return { top:[1,2], bottom:[0,3] };
    case 5: return { top:[2,3], bottom:[1,0,4] };
    case 6: return { top:[2,3,4], bottom:[1,0,5] };
    default: return null;
  }
}

function renderPlayerLines(players){
  clearPlayerStacks();
  if (!players || !players.length) return;
  if (centerRowWrap.classList.contains('hidden')) return;
  if (playerLinesWrap.classList.contains('hidden')) return;

  updatePlayerLinesGeometry();

  const lineTopY = parseFloat(playerLineTop.style.top || '0');
  const lineBottomY = parseFloat(playerLineBottom.style.top || '0');

  const r = centerRowWrap.getBoundingClientRect();
  const lineW = parseFloat(playerLineTop.style.width || `${Math.max(260, Math.min(920, r.width - 24))}`);
  const left = (window.innerWidth / 2) - (lineW / 2);
  const right = left + lineW;

  const g = state.game || null;
  const currentTurnPlayerId = g?.turnPlayerId || null;
  const currentTurnPlaced = !!g?.turnPlaced;

  function xAt(i, count){
    const DOT_W = 26, DOT_GAP = 3;
    const DOTS_W = (DOT_W * 4) + (DOT_GAP * 3);
    const HALF = DOTS_W / 2;
    const PAD = 16;

    const safeMin = Math.max(left, PAD + HALF);
    const safeMax = Math.min(right, window.innerWidth - PAD - HALF);

    if (count <= 1) return clamp((safeMin + safeMax) / 2, safeMin, safeMax);

    const t = i / (count - 1);
    const x = safeMin + (safeMax - safeMin) * t;
    return clamp(x, safeMin, safeMax);
  }

  function makeStack(p, x, y){
    const stack = document.createElement('div');
    const isMe = (p.id === state.userId);
    stack.className = 'player-stack' + (isMe ? ' me' : '');
    stack.style.left = `${x}px`;
    stack.style.top  = `${y}px`;

    const tag = document.createElement('div');
    tag.className = 'player-tag' + (isMe ? ' me' : '');
    tag.textContent = p.name;

    tag.onclick = () => {
      if (p.id === state.userId) return;
      if (!state.roomCode) return;
      if (state.seatedTable !== null) return;

      pendingSeatIndexToSteal = p.seatIndex;
      pendingSeatPlayerIdToSteal = p.id;
      kickMessage.textContent = `「${p.name}」を追い出して、この席に着席しますか？`;
      kickDialog.classList.remove('hidden');
    };

    const dots = document.createElement('div');
    dots.className = 'player-dots';

    const key = p.chipColor || 'red';
    const { bg, fg } = chipStyleFromKey(key);

    const usedArr = (Array.isArray(p.chipUsed) && p.chipUsed.length === 4) ? p.chipUsed : [false,false,false,false];
    const firstIdx0ForP = firstUnusedChipIndex0(usedArr);

    const isTurnPlayer = (!!currentTurnPlayerId && p.id === currentTurnPlayerId);
    const shouldPulseUnplacedNow = (!!g?.started && isTurnPlayer && !currentTurnPlaced);

    for (let i=1;i<=4;i++){
      const idx0 = i - 1;
      const d = document.createElement('div');
      d.className = 'player-dot';
      d.textContent = '';

      d.style.background = bg;
      d.style.color = fg;
      d.style.borderColor = (key === 'white') ? 'rgba(0,0,0,.35)' : 'rgba(0,0,0,.25)';

      d.appendChild(makeChipShapeEl(i));

      if (usedArr[idx0]) d.classList.add('used');

      if (shouldPulseUnplacedNow && firstIdx0ForP >= 0 && idx0 === firstIdx0ForP){
        d.classList.add('turn-pulsing');
      }

      if (isMe){
        const iAmTurnAndNotPlacedYet = (isMe && currentTurnPlayerId === state.userId && !currentTurnPlaced);
        if (!iAmTurnAndNotPlacedYet) d.classList.add('disabled');

        if (iAmTurnAndNotPlacedYet){
          if (firstIdx0ForP < 0 || idx0 !== firstIdx0ForP) d.classList.add('disabled');
        }

        d.addEventListener('pointerdown', (e) => {
          if (!state.roomCode) return;
          if (!isMe) return;
          if (d.classList.contains('disabled')) return;
          if (d.classList.contains('used')) return;

          e.preventDefault();
          beginChipDrag(d, {
            type: i,
            ownerId: state.userId,
            colorKey: key,
            seatIndex: p.seatIndex,
            sourceEl: d,
            sourceDotIndex0based: idx0
          }, e);
        }, { passive:false });

        d.addEventListener('contextmenu', (e) => e.preventDefault());
      }

      dots.appendChild(d);
    }

    stack.appendChild(tag);
    stack.appendChild(dots);
    return stack;
  }

  const rotated = rotatePlayersByMySeat(players);
  const n = rotated.length;
  const layout = getLayoutOrderIndices(n);

  if (layout){
    const topList = layout.top.map(i => rotated[i]).filter(Boolean);
    const bottomList = layout.bottom.map(i => rotated[i]).filter(Boolean);

    topList.forEach((p, i) => {
      const x = xAt(i, topList.length);
      playerLinesWrap.appendChild(makeStack(p, x, lineTopY));
    });

    bottomList.forEach((p, i) => {
      const x = xAt(i, bottomList.length);
      playerLinesWrap.appendChild(makeStack(p, x, lineBottomY));
    });

    return;
  }

  const topCount = Math.ceil(n / 2);
  const bottomCount = n - topCount;

  const topPlayers = rotated.slice(0, topCount);
  const bottomPlayers = rotated.slice(topCount);

  topPlayers.forEach((p, i) => {
    const x = xAt(i, topPlayers.length);
    playerLinesWrap.appendChild(makeStack(p, x, lineTopY));
  });

  bottomPlayers.forEach((p, i) => {
    const x = xAt(i, bottomPlayers.length);
    playerLinesWrap.appendChild(makeStack(p, x, lineBottomY));
  });
}

kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const used = await getUsedChipColorKeys();
  const myColor = pickUniqueChipColor(used);

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef, {
    playerId: state.userId,
    playerName: state.userName || '名無し',
    chipColor: myColor,
    chipUsed: [false,false,false,false]
  });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  seatPop.classList.add('hidden');

  await ensureChipUsedInitializedForSeat(seatIndex);
});

function buildTableCardsFromHelpRule(){
  const hc = (state.helpCards && state.helpCards.length) ? state.helpCards : DEFAULT_HELP_CARDS;

  const is10Enabled = !!hc.find(x => String(x.label) === '10')?.enabled;
  const isXEnabled  = !!hc.find(x => String(x.label) === 'X')?.enabled;

  const labels = [];
  for (let i=1;i<=9;i++) labels.push(String(i));
  if (is10Enabled) labels.push('10');
  if (isXEnabled) labels.push('X');

  if (isXEnabled){
    const numericPool = is10Enabled
      ? ['1','2','3','4','5','6','7','8','9','10']
      : ['1','2','3','4','5','6','7','8','9'];

    const toRemove = numericPool[Math.floor(Math.random() * numericPool.length)];
    const idx = labels.indexOf(toRemove);
    if (idx >= 0) labels.splice(idx, 1);
  }

  const objs = labels.map(label => ({ label }));
  shuffleInPlace(objs);

  return objs.map(x => ({
    id: crypto.randomUUID(),
    label: x.label
  }));
}

hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => {
  startPop.classList.add('hidden');
});

async function resetAllChipsAndInitTurn(){
  if (!state.roomCode) return;

  clearPendingCirclePushCommits();

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const players = Object.entries(tables)
    .map(([seat, t]) => (t && t.playerId ? ({ seatIndex:Number(seat), playerId:String(t.playerId) }) : null))
    .filter(Boolean)
    .sort((a,b)=>a.seatIndex-b.seatIndex);

  const order = players.map(x => x.playerId);
  if (order.length === 0) return;

  const firstIndex = Math.floor(Math.random() * order.length);
  const firstPlayerId = order[firstIndex];

  const baseRef = ref(db, `rooms/${state.roomCode}`);
  const patch = {};

  for (const p of players){
    patch[`tables/${p.seatIndex}/chipUsed`] = [false,false,false,false];
  }

  patch[`chipPlacements`] = null;
  patch[`circleChips`] = null;

  patch[`game`] = {
    started: true,
    playerOrder: order,
    turnIndex: firstIndex,
    turnPlayerId: firstPlayerId,
    turnPlaced: false,
    turnSeq: 1,
    lastPlacement: null,
    lastReorder: null,
    revealPhase: null
  };

  await update(baseRef, patch);

  moveUnlockAtMs = 0;
  moveAllowedCardId = null;
  zoomForced = false;
  closeZoom();
  stopRevealTicker();
}

btnGameStart.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  const ccRef = ref(db, `rooms/${state.roomCode}/centerCards`);
  const toPlace = buildTableCardsFromHelpRule();

  await set(ccRef, toPlace);

  await resetAllChipsAndInitTurn();

  startPop.classList.add('hidden');
});

btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  clearPendingCirclePushCommits();

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
    remove(ref(db, `${base}/centerCards`)),
    remove(ref(db, `${base}/chipPlacements`)),
    remove(ref(db, `${base}/circleChips`)),
    remove(ref(db, `${base}/game`))
  ]);

  state.seatedTable = null;
  startPop.classList.add('hidden');
  stopRevealTicker();
  await syncSeatUI();

  updateCenterCardSizing();
  updatePlayerLinesGeometry();
  renderPlayerLines(state.players || []);
  renderCircleChips();
});
</script>

</body>
</html>
